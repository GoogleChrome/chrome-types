/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License t
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import * as typedocModels from 'typedoc/dist/lib/models/index.js';
import * as symbolTypes from '../../types/symbol.js';
import * as htmlEscaper from 'html-escaper';


/**
 * Format a long-form comment to HTML for rendering on a real page. This will return a HTML string
 * that is wrapped in elements such as <p> and <ul>.
 *
 * @template T
 * @param {typedocModels.Comment|string|undefined} comment
 * @param {symbolTypes.CommentHelper<T>} helper
 * @return {string}
 */
export function formatComment(comment, helper) {
  if (!comment) {
    return '';
  }

  let raw = '';
  if (typeof comment === 'string') {
    raw = comment;
  } else {
    // TypeDoc generates both a shortText and text field, which are the same parts of the comment.
    // Merge them before we continue. This can often be the cause (below) of
    // "content\n<p>more content</p>".
    raw = comment?.shortText ?? '';
    if (raw && comment?.text) {
      raw += '\n';
    }
    raw += comment?.text ?? '';
  }

  raw = formatCommentLine(raw, helper);
  return ensureCommentSafeHTML(raw);
}


/**
 * Formats a short-form comment, such as for a at-deprecated notice. This returns HTML but does not
 * add or ensure normal paragraph elements such as <p> or <ul>.
 *
 * @template T
 * @param {string} text
 * @param {symbolTypes.CommentHelper<T>} helper
 * @return {string}
 */
export function formatCommentLine(text, helper) {
  // Rewrite all existing URLs. Do this before @link matching, so we don't get called twice.
  text = text.replace(/href=(["'])(.*?)\1/g, (_, _quote, inner) => {
    let out = helper.resolveExistingHref(inner);
    if (out && typeof out !== 'string') {
      out = helper.generateHref(out);
    }
    return out ? `href="${out}"` : '';
  });

  // Rewrite all @link matching to real URLs.
  text = text.replace(/\{@link\s+([^}\s]+)\s*(.*?)}/gs, (_, id, note) => {
    const resolved = helper.resolveLink(id);
    const inner = note ? note : `<code>${id}</code>`;

    // Generate a href, and include in <a> if available.
    const href = resolved ? helper.generateHref(resolved) : '';
    if (href) {
      return `<a href="${href}">${inner}</a>`;
    }
    return inner;
  });

  return text;
}


/**
 * Wraps the passed comment in HTML. Ensures the comment is comprised of top-level tags.
 *
 * @param {string} out
 * @return {string}
 */
function ensureCommentSafeHTML(out) {
  out = out.trim();
  if (!out) {
    return '';
  }

  // No paragraph wrapper, include one and return.
  if (!out.includes('<p>')) {
    return `<p>${out}</p>`;
  }

  // Already wrapped in a paragraph. Return.
  if (out.startsWith('<p>') && out.endsWith('</p>')) {
    return out;
  }

  // This is a comment which looks like, and is regularly generated by TS:
  //
  //    Hello, I am some long-form content!
  //    <p>For some reason there's a trailing paragraph!</p>
  //    <pre>/* often a code block here too */</pre>
  //
  // We put the first part in a paragraph.
  if (/<\/\w+>$/.test(out)) {
    const indexOfParagraph = out.indexOf('<p>');
    const initialPart = out.substr(0, indexOfParagraph);
    const restPart = out.substr(indexOfParagraph);
    return `<p>${initialPart}</p>\n${restPart}`;
  }

  // Works around specific issue.
  if (out.endsWith('<p>')) {
    out = out.substr(0, out.length - 3);
    return ensureCommentSafeHTML(out);
  }

  // Drop all HTML entities from this. This only happens in one case where
  // inline HTML is used to demonstrate an example.
  out = htmlEscaper.escape(out);
  return ensureCommentSafeHTML(out);
}

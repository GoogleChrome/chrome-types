'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var typedocModels = require('typedoc/dist/lib/models/index.js');
var htmlEscaper = require('html-escaper');
var index_js = require('typedoc/dist/lib/utils/index.js');
var typedoc = require('typedoc');
require('typescript');

/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License t
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Format a long-form comment to HTML for rendering on a real page. This will return a HTML string
 * that is wrapped in elements such as <p> and <ul>.
 *
 * @template T
 * @param {typedocModels.Comment|string|undefined} comment
 * @param {symbolTypes.CommentHelper<T>} helper
 * @return {string}
 */
function formatComment(comment, helper) {
  if (!comment) {
    return '';
  }

  let raw = '';
  if (typeof comment === 'string') {
    raw = comment;
  } else {
    // TypeDoc generates both a shortText and text field, which are the same parts of the comment.
    // Merge them before we continue. This can often be the cause (below) of
    // "content\n<p>more content</p>".
    raw = comment?.shortText ?? '';
    if (raw && comment?.text) {
      raw += '\n';
    }
    raw += comment?.text ?? '';
  }

  raw = formatCommentLine(raw, helper);
  return ensureCommentSafeHTML(raw);
}


/**
 * Formats a short-form comment, such as for a at-deprecated notice. This returns HTML but does not
 * add or ensure normal paragraph elements such as <p> or <ul>.
 *
 * @template T
 * @param {string} text
 * @param {symbolTypes.CommentHelper<T>} helper
 * @return {string}
 */
function formatCommentLine(text, helper) {
  // Rewrite all existing URLs. Do this before @link matching, so we don't get called twice.
  text = text.replace(/href=(["'])(.*?)\1/g, (_, _quote, inner) => {
    let out = helper.resolveExistingHref(inner);
    if (out && typeof out !== 'string') {
      out = helper.generateHref(out);
    }
    return out ? `href="${out}"` : '';
  });

  // Rewrite all @link matching to real URLs.
  text = text.replace(/\{@link\s+([^}\s]+)\s*(.*?)}/gs, (_, id, note) => {
    const resolved = helper.resolveLink(id);
    const inner = note ? note : `<code>${id}</code>`;

    // Generate a href, and include in <a> if available.
    const href = resolved ? helper.generateHref(resolved) : '';
    if (href) {
      return `<a href="${href}">${inner}</a>`;
    }
    return inner;
  });

  return text;
}


/**
 * Wraps the passed comment in HTML. Ensures the comment is comprised of top-level tags.
 *
 * @param {string} out
 * @return {string}
 */
function ensureCommentSafeHTML(out) {
  out = out.trim();
  if (!out) {
    return '';
  }

  // No paragraph wrapper, include one and return.
  if (!out.includes('<p>')) {
    return `<p>${out}</p>`;
  }

  // Already wrapped in a paragraph. Return.
  if (out.startsWith('<p>') && out.endsWith('</p>')) {
    return out;
  }

  // This is a comment which looks like, and is regularly generated by TS:
  //
  //    Hello, I am some long-form content!
  //    <p>For some reason there's a trailing paragraph!</p>
  //    <pre>/* often a code block here too */</pre>
  //
  // We put the first part in a paragraph.
  if (/<\/\w+>$/.test(out)) {
    const indexOfParagraph = out.indexOf('<p>');
    const initialPart = out.substr(0, indexOfParagraph);
    const restPart = out.substr(indexOfParagraph);
    return `<p>${initialPart}</p>\n${restPart}`;
  }

  // Works around specific issue.
  if (out.endsWith('<p>')) {
    out = out.substr(0, out.length - 3);
    return ensureCommentSafeHTML(out);
  }

  // Drop all HTML entities from this. This only happens in one case where
  // inline HTML is used to demonstrate an example.
  out = htmlEscaper.escape(out);
  return ensureCommentSafeHTML(out);
}

/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License t
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {typedocModels.Reflection=} reflection
 * @return {boolean}
 */
function isOptional(reflection) {
  if (!reflection) {
    return false;
  }
  return reflection.flags.hasFlag(typedocModels.ReflectionFlag.Optional);
}


/**
 * Finds an array type from the passed model type. This is required as we also infer restricted
 * array types from tuples, intersection and union types.
 *
 * @param {typedocModels.Type=} type
 * @return {{
 *   min?: number,
 *   max?: number,
 *   elementType: typedocModels.Type,
 * }=}
 */
function matchArrayType(type) {
  if (!type) {
    return;
  }

  if (type.type === 'reflection') {
    const literal = internalMatchTypeLiteralOnly(type);
    if (literal) {
      const properties = literal;
      if (!properties['0']) {
        return;
      }
      const zeroReflection = properties[0];
      if (!zeroReflection.type) {
        return;
      }
      const check = new Set(Object.keys(properties));

      let i = 0;
      for (;;) {
        const key = `${i}`;
        const reflection = properties[key];
        if (reflection === undefined) {
          break;
        }
        if (isOptional(reflection) || !reflection.type?.equals(zeroReflection.type)) {
          return;
        }
        check.delete(key);
        ++i;
      }
      if (check.size) {
        return;
      }

      return {min: i, max: i, elementType: zeroReflection.type};
    }
  }

  if (type.type === 'array') {
    const arrayType = /** @type {typedocModels.ArrayType} */ (type);
    return {elementType: arrayType.elementType};
  }

  if (type.type === 'tuple') {
    const tupleType = /** @type {typedocModels.TupleType} */ (type);
    const [first, ...rest] = tupleType.elements;

    // We just support tuples of the same type. This is an array of fixed length.
    const invalid = rest.some(check => !check.equals(first));
    if (!first || invalid) {
      return;
    }

    const length = tupleType.elements.length;
    return {
      min: length,
      max: length,
      elementType: first,
    };
  }

  const isIntersection = (type.type === 'intersection');
  if (isIntersection || type.type === 'union') {
    const t = /** @type {typedocModels.IntersectionType|typedocModels.UnionType} */ (type);

    const firstArray = matchArrayType(t.types[0]);
    if (!firstArray) {
      return;
    }

    let min = firstArray.min ?? 0;
    let max = firstArray.max ?? Infinity;

    // Make sure all other types in this intersection are also arrays of the same elementType.
    // In reality, this will probably only ever be (A & B), but it could be more.
    for (let i = 1; i < t.types.length; ++i) {
      const restArray = matchArrayType(t.types[i]);
      if (!restArray || !restArray.elementType.equals(firstArray.elementType)) {
        return;
      }

      // TODO(samthor): This isn't right for a bunch of cases but we probably don't care right now.
      // For instance, `[T, T] & [T, T, T, T]` would also allow 3 elements, because the return type
      // doesn't support passing both around. (Perhaps an inner accumulator could be more correct?)
      // This doesn't actually appear in Chrome's extension code right now.
      if (isIntersection) {
        min = Math.max(min, restArray.min ?? 0);
        max = Math.max(max, restArray.max ?? Infinity);
      } else {
        min = Math.min(min, restArray.min ?? 0);
        max = Math.max(max, restArray.max ?? Infinity);
      }
    }

    const out = {
      elementType: firstArray.elementType,
    };
    if (min !== 0) {
      out.min = min;
    }
    if (max !== Infinity) {
      out.max = max;
    }
  
    return out;
  }
}


/**
 * @param {typedocModels.Type} type
 * @return {{[name: string]: typedocModels.DeclarationReflection}=}
 */
function internalMatchTypeLiteralOnly(type) {
  if (type.type !== 'reflection') {
    return;
  }

  const reflectionType = /** @type {typedocModels.ReflectionType} */ (type);
  const declaration = reflectionType.declaration;
  if (declaration.kind !== typedocModels.ReflectionKind.TypeLiteral) {
    return;
  }

  /** @type {{[name: string]: typedocModels.DeclarationReflection}} */
  const properties = {};
  (declaration.children ?? []).forEach((child) => {
    properties[child.name] = child;
  });
  return properties;
}


/**
 * Finds a type literal, possibly intersected with another initial root type.
 *
 * The intersection case is found inside {@link chrome.storage} as some type instances also have
 * properties applied to them.
 *
 * @param {typedocModels.Type=} type
 * @return {{
 *   root?: typedocModels.Type,
 *   properties: {[name: string]: typedocModels.DeclarationReflection},
 * }=}
 */
function matchTypeLiteral(type) {
  if (!type) {
    return;
  }

  // This could just be a type literal on its own.
  const internal = internalMatchTypeLiteralOnly(type);
  if (internal) {
    return {properties: internal};
  }

  // Otherwise, see if this is an intersection with a type literal only.
  if (type.type !== 'intersection') {
    return;
  }
  const t = /** @type {typedocModels.IntersectionType} */ (type);

  /** @type {{[name: string]: typedocModels.DeclarationReflection}} */
  const properties = {};

  const firstTypeLiteral = internalMatchTypeLiteralOnly(t.types[0]);
  if (firstTypeLiteral !== undefined) {
    // This was a type literal, not a root. Assign outside the loop below.
    Object.assign(properties, firstTypeLiteral);
  }

  for (let i = 1; i < t.types.length; ++i) {
    const restTypeLiteral = internalMatchTypeLiteralOnly(t.types[i]);
    if (!restTypeLiteral) {
      // We expect this to be of a certain shape: it has properties and no other type.
      return;
    }
    Object.assign(properties, restTypeLiteral);
  }

  const out = {properties};
  if (firstTypeLiteral === undefined) {
    out.root = t.types[0];
  }
  return out;
}


/**
 * Finds an enum made up of literal values (e.g., specific numbers, strings and so on).
 *
 * This accepts a reflection, not a type, as we must be able to infer that this is a TypeAlias.
 *
 * @param {typedocModels.Reflection=} reflection
 * @return {symbol.LiteralTypeOption[]|undefined}
 */
function matchEnum(reflection) {
  if (!(reflection instanceof typedocModels.DeclarationReflection)) {
    return;
  }

  if (reflection.kind !== typedocModels.ReflectionKind.TypeAlias) {
    return;
  }
  const {type: stringType} = reflection.type ?? {type: ''};

  // Try to find a single literal under a TypeAlias.
  if (stringType === 'literal') {
    const literalType = /** @type {typedocModels.LiteralType} */ (reflection.type);
    return [literalType.value];
  }

  if (stringType !== 'union') {
    return;
  }
  const unionType = /** @type {typedocModels.UnionType} */ (reflection.type);
  const literalTypes = [];
  for (const candidate of unionType.types) {
    if (!(candidate instanceof typedocModels.LiteralType)) {
      // This is too hard, don't try to enum this.
      return;
    }
    literalTypes.push(candidate);
  }

  return literalTypes.map(({value}) => value);
}


/**
 * Finds a single function definition based on many possible signatures. This is entirely to deal
 * with Chrome's middle-optional arguments. For two signatures like:
 * 
 * func(number, string, string?)
 * func(string, string?)
 *
 * This will return three arguments: [number?, string, string?].
 * 
 * This will not match if the types are incompatible.
 *
 * TODO(samthor): When we include the Promise<> return type, this will fail.
 *
 * @param {typedocModels.Reflection=} reflection
 * @return {{
 *   returnType: typedocModels.Type,
 *   parameters: {
 *     name: string,
 *     type: typedocModels.Type,
 *     optional: boolean,
 *     reflection: typedocModels.ParameterReflection,
 *   }[],
 *   signature: typedocModels.SignatureReflection,
 * }=}
 */
function matchUnifiedFunction(reflection) {
  if (!(reflection instanceof typedocModels.DeclarationReflection) || !reflection.signatures?.length) {
    return;
  }

  const {signatures} = reflection;
  signatures.sort((a, b) => {
    return (b.parameters?.length ?? 0) - (a.parameters?.length ?? 0);
  });
  const bestSignature = /** @type {typedocModels.SignatureReflection} */ (signatures[0]);
  const returnType = /** @type {typedocModels.Type} */ (bestSignature.type);

  const parameters = (bestSignature.parameters ?? []).map((param) => {
    return {
      name: param.name,
      type: /** @type {typedocModels.Type} */ (param.type),
      optional: isOptional(param),
      reflection: param,
    };
  });

  for (let i = 1; i < signatures.length; ++i) {
    const other = signatures[i];
    if (!other.type?.equals(returnType)) {
      // Abandon if the return type is not the same.
      return;
    }

    // Walk through the parameters of the smaller type and look for gaps. If we find any, then
    // update the return parameters to be optional (even on the left). This will also abandon
    // if we can't find an in-order matching type in the larger signature.

    let workParameters = parameters.slice();
    for (const otherParam of other.parameters ?? []) {
      const update = workParameters.findIndex(({name}) => name === otherParam.name);
      if (update === -1) {
        // The param wasn't found in the best candidate.
        return;
      }
      if (!otherParam.type?.equals(workParameters[update].type)) ;
 
      for (let i = 0; i < update; ++i) {
        workParameters[i].optional = true;
      }
      workParameters = workParameters.slice(update + 1);
    }

    // It doesn't matter if workParameters still has values, this just means the parameters weren't
    // specified in the smaller type.
  }

  return {
    returnType,
    parameters,
    signature: bestSignature,
  };
}


/**
 * Checks if this is a union of undefined and something else, returning the other type. This is
 * sometimes how variables are expressed as optional (as they cannot have ? applied to them).
 *
 * @param {typedocModels.Type} type
 * @return {typedocModels.Type=}
 */
function matchOptionalType(type) {
  if (type.type !== 'union') {
    return;
  }
  const unionType = /** @type {typedocModels.UnionType} */ (type);
  if (unionType.types.length !== 2) {
    return;
  }

  const filtered = unionType.types.filter((t) => {
    if (t.type !== 'intrinsic') {
      return true;
    }
    const it = /** @type {typedocModels.IntrinsicType} */ (t);
    return it.name !== 'undefined';
  });
  if (filtered.length !== 1) {
    return;
  }

  return filtered[0];
}

/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License t
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {string[]} fileNames
 * @param {Partial<typedoc.TypeDocOptions>} bootstrapOptions
 * @param {ts.CompilerOptions} compilerOptions
 * @return {typedocModels.ProjectReflection}
 */
function generateTypeDocObjectOptions(fileNames, bootstrapOptions, compilerOptions) {
  const a = new typedoc.Application();
  a.bootstrap({
    logger(message, level) {
      switch (level) {
        case index_js.LogLevel.Warn:
        case index_js.LogLevel.Error:
          throw new Error(`could not convert types: ${message}`);
      }
    },
    ...bootstrapOptions,
  });

  // TypeDoc complains if we don't set some options, even though it runs fine.
  a.options.setCompilerOptions(fileNames, compilerOptions, undefined);

  const reflection = a.convert();
  if (!reflection) {
    throw new Error(`could not parse: ${fileNames.join(',')}`);
  }
  return reflection;

}


/**
 * Generates the TypeDoc internal representation for the passed source. This invokes typedoc's
 * Application bundle and throws on failures.
 *
 * @param {string} sourceFile
 * @param {string[]} extraSources
 * @return {typedocModels.ProjectReflection}
 */
function generateTypeDocObject(sourceFile, ...extraSources) {
  const entryPoints = [sourceFile, ...extraSources];
  return generateTypeDocObjectOptions(entryPoints, {entryPoints}, {declaration: true});
}

/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License t
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const rk = typedocModels.ReflectionKind;


const knownMagicNames = ['__call', '__type', '__index'];


/**
 * Insert this instead of "." between an interface or function and one of its properties. This
 * can be the dot too, but JSDoc uses "#". TSDoc as of 4.1.3 can't resolve _either_ in at-see or
 * at-link declarations, and only links to functions, interfaces, namespaces or enums (and values).
 */
const propertyDelimiter = '.';


/**
 * @param {typedocModels.Reflection} r
 * @param {string[]} idParts
 */
function internalResolveChild(r, idParts) {
  if (r.kind === rk.Function || r.kind === rk.Method) {
    const decl = /** @type {typedocModels.DeclarationReflection} */ (r);

    for (const signature of decl.signatures ?? []) {
      const result = internalResolveChild(signature, idParts);
      if (result) {
        return result;
      }
    }
    return;
  }

  const left = idParts[0];
  const child = r.getChildByName(left);

  if (child) {
    if (idParts.length === 1) {
      return child;
    }
    idParts = idParts.slice(1);
    return internalResolveChild(child, idParts);
  }

  // If we can't find a child, check known magic names and skip them.
  // TODO(samthor): This relies on no-one declaring e.g., "__type" as a var.
  for (const knownMagic of knownMagicNames) {
    const magic = r.getChildByName(knownMagic);
    if (!magic) {
      continue;
    }
    const cand = internalResolveChild(magic, idParts);
    if (cand) {
      return cand;
    }
  }
}


/**
 * Resolves the ambiguous "foo.Bar" syntax into a complete Reflection for the given owner
 * Reflection, or void if not available in this project.
 * 
 * This is an improvement over TypeDoc's internal resolver as it:
 *   - allows arbitrary dividers between properties
 *   - descends into dup named calls and magic names
 *
 * This can return an ambiguous result, but TypeDoc's internal resolver is *already* ambiguous for
 * functions with multiple signatures.
 *
 * @param {typedocModels.Reflection} owner
 * @param {string} name
 * @return {typedocModels.Reflection|void}
 */
function resolveLink(owner, name) {
  const idParts = name.split(/[^a-zA-Z0-9_]/g);
  let result = undefined;

  closest(owner, (cand) => {
    result = internalResolveChild(cand, idParts);
    return Boolean(result);
  });

  return result;
}


/**
 * Finds the closest parent Reflection that satisfies the caller.
 * 
 * @param {typedocModels.Reflection|void} reflection
 * @param {(cand: typedocModels.Reflection) => boolean} check
 * @return {typedocModels.Reflection|void}
 */
function closest(reflection, check) {
  while (reflection) {
    if (check(reflection)) {
      return reflection;
    }
    reflection = reflection.parent;
  }
  return undefined;
}


/**
 * Generates the FQDN for this reflection.
 *
 * This is improved over TypeDoc's generation:
 *   - hides internal __call etc types
 *   - doesn't include the module/filename
 *
 * It's only useful for names within a specific project or module. Notably this works for Chrome
 * and friends because they declare a new global namespace, "chrome".
 *
 * @param {typedocModels.Reflection} reflection
 * @return {string}
 */
function fullName(reflection) {
  /** @type {typedocModels.Reflection|undefined} */
  let r = reflection;

  const parts = [];
  while (r && r.kind !== rk.Module && r.kind !== rk.Project) {
    const {parent} = r;

    // Insert "~" when this looks at the type or call bridge. This only happens when we record
    // the properties of a type or arguments to a function. Chrome's docs historically don't report
    // this information, instead only providing information on top-level types.
    if (r.name.startsWith('__')) {
      if (!knownMagicNames.includes(r.name)) {
        throw new Error(`unknown magic: ${r.name}, ${reflection.getFullName()}`);
      }
      if (parts.length && parts[0] !== '~') {
        parts.unshift('~');
      }
    } else {
      // If we have a node with a leading "_", see if there's a matching parent without it.
      // This solves our awkward approach to escaping, which exports e.g., the real type
      // "_debugger" under a friendly alias "debugger".
      if (/^_\w/.test(r.name)) {
        const checkName = r.name.slice(1);
        const check = r.parent?.getChildByName(checkName);
        r = check ?? r;
      }

      if (r.name.length) {
        parts.unshift(r.name);
      }
    }

    // If this is the _type_ of a CallSignature, then skip over it (duplicate name).
    if (
      r.kind === rk.CallSignature &&
      (parent?.kind === rk.Function || parent?.kind === rk.Method)
    ) {
      if (r.name !== parent.name) {
        throw new TypeError(
          `signature did not match function: ${r.name} vs ${parent.name}`
        );
      }
      r = parent.parent;
      continue;
    }

    r = r.parent;
  }

  // We insert `~` instead of magic names, but it ends up being displayed as `.~.`. Fix that and
  // use the property delimiter.
  return parts.join('.').replace(/\.~\./g, propertyDelimiter).replace(/^\./, '');
}


/**
 * Finds the exported children of this Reflection.
 * 
 * @param {typedocModels.Reflection=} reflection
 * @param {typedocModels.ReflectionKind=} kindMask
 * @return {{[name: string]: typedocModels.DeclarationReflection}}
 */
function exportedChildren(reflection, kindMask = 0) {
  /** @type {{[name: string]: typedocModels.DeclarationReflection}} */
  const all = {};

  if (!(reflection instanceof typedocModels.ContainerReflection)) {
    return all;
  }

  // TODO(samthor): The way we currently parse the .d.ts files _only_ generates exported types, and
  // they're not marked as such.
  // This might change in future.

  const arr = reflection.children ?? [];
  arr.sort(({name: a}, {name: b}) => a.localeCompare(b));

  for (const cand of arr) {
    if (kindMask && !(cand.kind & kindMask)) {
      continue;
    }
    all[cand.name] = cand;
  }

  return all;
}

exports.closest = closest;
exports.exportedChildren = exportedChildren;
exports.formatComment = formatComment;
exports.formatCommentLine = formatCommentLine;
exports.fullName = fullName;
exports.generateTypeDocObject = generateTypeDocObject;
exports.generateTypeDocObjectOptions = generateTypeDocObjectOptions;
exports.internalMatchTypeLiteralOnly = internalMatchTypeLiteralOnly;
exports.isOptional = isOptional;
exports.matchArrayType = matchArrayType;
exports.matchEnum = matchEnum;
exports.matchOptionalType = matchOptionalType;
exports.matchTypeLiteral = matchTypeLiteral;
exports.matchUnifiedFunction = matchUnifiedFunction;
exports.resolveLink = resolveLink;
